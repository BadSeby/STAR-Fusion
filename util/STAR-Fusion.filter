#!/usr/bin/env perl

use strict;
use warnings;
use Carp;
use FindBin;
use lib ("$FindBin::Bin/../lib");
use Fasta_reader;
use Getopt::Long qw(:config posix_default no_ignore_case bundling pass_through);                                                 
use TiedHash;

my $cdna_fasta_file = "$FindBin::Bin/../resources/gencode.v19.annotation.gtf.exons.cdna.gz";

my $Evalue = 1e-3;
my $tmpdir = "/tmp";

my $MIN_NOVEL_JUNCTION_SUPPORT = 5;
my $MIN_ALT_PCT_JUNCTION = 10;
my $AGGREGATE_NOVEL_JUNCTION_DIST = 5;
my $MIN_SPAN_ONLY_SUPPORT = 5;


my $usage = <<__EOUSAGE__;

###################################################################################################
#
# Required:
#
#  --fusion_preds <string>        preliminary fusion predictions
#                                 Required formatting is:  
#                                 geneA--geneB (tab) junction_read_count (tab) spanning_read_count (tab) ... rest
#
#  --out_prefix <string>          prefix for output filename (will tack on .final and .final.abridged)
#
# Optional: 
#
#  --ref_cdna <string>            reference cDNA sequences fasta file (generated specially based on gtf -see docs) 
#                                 (default: $cdna_fasta_file)
#
#  -E <float>                     E-value threshold for blast searches (default: $Evalue)
#
#  --tmpdir <string>              file for temporary files (default: $tmpdir)
#
#  --min_novel_junction_support <int>    default: $MIN_NOVEL_JUNCTION_SUPPORT  (minimum of $MIN_NOVEL_JUNCTION_SUPPORT junction reads required if breakpoint
#                                                        lacks involvement of only reference junctions)
#
#  --min_alt_pct_junction <float>        default: $MIN_ALT_PCT_JUNCTION  ($MIN_ALT_PCT_JUNCTION % of the dominant isoform junction support)
#
#  --min_span_only_support <int>         default: $MIN_SPAN_ONLY_SUPPORT (minimum of $MIN_SPAN_ONLY_SUPPORT) spanning frags required if no junction reads are found
#
#  --aggregate_novel_junction_dist <int>  default: $AGGREGATE_NOVEL_JUNCTION_DIST (non-ref junctions within $AGGREGATE_NOVEL_JUNCTION_DIST are merged into single calls)
#
####################################################################################################


__EOUSAGE__

    ;

my $help_flag;

my $fusion_preds_file;
my $out_prefix;

&GetOptions ( 'h' => \$help_flag, 
              
              'fusion_preds=s' => \$fusion_preds_file,
              'ref_cdna=s' => \$cdna_fasta_file,
              
              'out_prefix=s' => \$out_prefix,

              'E=f' => \$Evalue,
              'tmpdir=s' => \$tmpdir,
              
              'min_novel_junction_support=i' => \$MIN_NOVEL_JUNCTION_SUPPORT,
              'min_alt_pct_junction=f' => \$MIN_ALT_PCT_JUNCTION,
              'aggregate_novel_junction_dist=i' => \$AGGREGATE_NOVEL_JUNCTION_DIST,

              'min_span_only_support=i' => \$MIN_SPAN_ONLY_SUPPORT,
              
              
    );

if (@ARGV) {
    die "Error, dont recognize arguments: @ARGV";
}


if ($help_flag) {
    die $usage;
}

unless ($fusion_preds_file && $cdna_fasta_file && $out_prefix) {
    die $usage;
}

my $ref_cdna_idx_file = "$cdna_fasta_file.idx";
unless (-s $ref_cdna_idx_file) {
    die "Error, cannot find indexed fasta file: $cdna_fasta_file.idx; be sure to build an index - see docs.\n";
}


my $CDNA_IDX = new TiedHash({ use => $ref_cdna_idx_file });

my $BLAST_PAIRS_IDX;
my $blast_pairs_idx_file = "$cdna_fasta_file.blastn_gene_pairs.gz.idx";
if (-s $blast_pairs_idx_file) {
    $BLAST_PAIRS_IDX = new TiedHash( { use => $blast_pairs_idx_file } );
}
else {
    print STDERR "Warning: cannot locate $blast_pairs_idx_file, running blastn directly.\n";
}

my %BLAST_CACHE;



=input_format:

0       ETV6--NTRK3
1       84
2       18
3       ONLY_REF_SPLICE
4       ETV6^ENSG00000139083.6
5       chr12:12022903:+
6       NTRK3^ENSG00000140538.12
7       chr15:88483984:-
8       comma-delim list of junction reads
9       comma-delim list of spanning frags

=cut


main: {

    unless (-d $tmpdir) {
        mkdir $tmpdir or die "Error, cannot mkdir $tmpdir";
    }
    
    
    
    my $final_preds_file = "$out_prefix.final";
    open (my $final_ofh, ">$final_preds_file") or die "Error, cannot write to $final_preds_file";
    
    my $filter_info_file = "$fusion_preds_file.filt_info";
    open (my $filter_ofh, ">$filter_info_file") or die "Error, cannot write to $filter_info_file";
    
    my @fusions;
    open (my $fh, $fusion_preds_file) or die "Error, cannot open file $fusion_preds_file";
    my $header = <$fh>;
    unless ($header =~ /^\#/) {
        die "Error, file $fusion_preds_file doesn't begin with a header line";
    }
    while (<$fh>) {
        chomp;

        my @x = split(/\t/);
        my $fusion_name = $x[0];
        my $J = $x[1];
        my $S = $x[2];
        my $splice_type = $x[3];
        my $geneA = $x[4];
        my $brkptA = $x[5];
        my $geneB = $x[6];
        my $brkptB = $x[7];
        my $junction_reads = $x[8] || '.';
        my $spanning_frags = $x[9] || '.';
        
        
        my $rest = "";
        if ($#x > 9) {
            $rest = join("\t", @x[10..$#x]);
        }
        
        #my $score = sqrt($J**2 + $S**2);
        my $score = $J*4 + $S;
        
        
        my $fusion = { fusion_name => $fusion_name,
                       
                       splice_type => $splice_type,
                       
                       J => $J,
                       S => $S,
                       
                       geneA => $geneA,
                       geneB => $geneB,
                       
                       brkptA => $brkptA,
                       brkptB => $brkptB,
                       
                       junction_reads => $junction_reads,
                       spanning_frags => $spanning_frags,
                       
                       score => $score, 
                       
                       rest => $rest,
                       
                       line => "", # set right below
        };
    
    
        my $line = join("\t", $fusion->{fusion_name}, $fusion->{J}, $fusion->{S}, $fusion->{splice_type},
                        $fusion->{geneA}, $fusion->{brkptA}, $fusion->{geneB}, $fusion->{brkptB},
                        $fusion->{junction_reads}, $fusion->{spanning_frags}, $fusion->{rest});
        

        $fusion->{line} = $line;  # note, we'll need to reset this later after merging occurs for some entries.
        
        push (@fusions, $fusion); 
    }
    
    print $filter_ofh $header;
    print $final_ofh $header;
    
    @fusions = reverse sort {$a->{score} <=> $b->{score} } @fusions;
    
    @fusions = &merge_neighboring_nonref_splice(\@fusions, $filter_ofh);

    @fusions = &remove_minor_nonref_isoforms(\@fusions, $filter_ofh);
    
    
    ########################
    ##  Filter and report ##
    ########################
    

    my %AtoB;
    my %BtoA;
    
    my %already_approved;

    foreach my $fusion (@fusions) {

        #my ($geneA, $geneB) = ($fusion->{geneA}, $fusion->{geneB});
        my ($geneA, $geneB) = split(/--/, $fusion->{fusion_name});


        #print STDERR "-encountered $geneA--$geneB\n\n";
        
        #print STDERR "Examining fusion: $geneA--$geneB\n";
        my @blast_info;

        if ($already_approved{$geneA}->{$geneB}) {
           
            #print STDERR "-already approved $geneA--$geneB\n";
        }
        else {
            
            @blast_info = &examine_seq_similarity($geneA, $geneB);
            if (@blast_info) {
                push (@blast_info, "SEQ_SIMILAR_PAIR");
            }
            else {
                
                my $altB_href = $AtoB{$geneA};
                if ($altB_href) {
                    foreach my $altB (keys %$altB_href) {
                        my @blast = &examine_seq_similarity($geneB, $altB);
                        if (@blast) {
                            push (@blast, "ALREADY_EXAMINED:$geneA--$altB");
                            push (@blast_info, @blast);
                        }
                    }
                }
                my $altA_href = $BtoA{$geneB};
                if ($altA_href) {
                    foreach my $altA (keys %$altA_href) {
                        my @blast = &examine_seq_similarity($altA, $geneA);
                        if (@blast) {
                            push (@blast, "ALREADY_EXAMINED:$altA--$geneB");
                            push (@blast_info, @blast);
                        }
                    }
                }
            }
        }
        
        
        # regenerating 'line' here, since merged entries will now have updated stats.        
        my $line = join("\t", $fusion->{fusion_name}, $fusion->{J}, $fusion->{S}, $fusion->{splice_type},
                        $fusion->{geneA}, $fusion->{brkptA}, $fusion->{geneB}, $fusion->{brkptB},
                        $fusion->{junction_reads}, $fusion->{spanning_frags}, $fusion->{rest});
        
        
        
        if (@blast_info) {
            $line ="#$line"; # comment out the line in the filtered file... an aesthetic.
        }
        print $filter_ofh "$line\t" . join("\t", @blast_info) . "\n";
        
        unless (@blast_info) {
            print $final_ofh "$line\n";
            $already_approved{$geneA}->{$geneB} = 1;
        }
        
        $AtoB{$geneA}->{$geneB} = 1;
        $BtoA{$geneB}->{$geneA} = 1;
                
    }

    close $filter_ofh;
    close $final_ofh;
    
    ## generate abrdiged versions, as all those read names take up a lot of space and are annoyoing to look at when you just want to know what fusions are predicted.

    &process_cmd("cut -f1-8,11-100 $filter_info_file > $filter_info_file.abridged");
    &process_cmd("cut -f1-8,11-100 $final_preds_file > $final_preds_file.abridged");
    

    exit(0);
}


####
sub examine_seq_similarity {
    my ($geneA, $geneB) = @_;
    
    #print STDERR "-examining seq similarity between $geneA and $geneB\n";

    my @blast_hits;
    

    if ($BLAST_PAIRS_IDX) {
        # use pre-computed blast pair data
        if (my $hit = $BLAST_PAIRS_IDX->get_value("$geneA--$geneB")) {
            return($hit);
        }
        elsif ($hit = $BLAST_PAIRS_IDX->get_value("$geneB--$geneA")) {
            return($hit);
        }
        else {
            return();
        }
    }
    
    # check for previously stored blast results or attempted search
    if (my $cache_aref = $BLAST_CACHE{"$geneA--$geneB"}) {
        my @hits = @$cache_aref;
        if (@hits) {
            #print STDERR "CACHED HITS FOR: $geneA--$geneB: [@hits]\n";
            return(@hits);
        }
        else {
            return();
        }
    }
    

    #print STDERR "-testing $geneA vs. $geneB\n";
    
    my $fileA = "$tmpdir/$$.gA.fa";
    my $fileB = "$tmpdir/$$.gB.fa";
        
    {
        # write file A
        open (my $ofh, ">$fileA") or die "Error, cannot write to $fileA";
        my $cdna_seqs = $CDNA_IDX->get_value($geneA) or confess "Error, no sequences found for gene: $geneA";
        print $ofh $cdna_seqs;
        close $ofh;
    }
        
    
    {
        # write file B
        open (my $ofh, ">$fileB") or die "Error, cannot write to file $fileB";
        my $cdna_seqs = $CDNA_IDX->get_value($geneB) or confess "Error, no sequences found for gene: $geneB";
        print $ofh $cdna_seqs;
        close $ofh;
    }
    
    #print STDERR "do it? ... ";
    #my $response = <STDIN>;
    
    ## blast them:
    my $cmd = "makeblastdb -in $fileB -dbtype nucl 2>/dev/null 1>&2";
    &process_cmd($cmd);
    
    my $blast_out = "$tmpdir/$$.blastn";
    $cmd = "blastn -db $fileB -query $fileA -evalue $Evalue -outfmt 6 -lcase_masking -max_target_seqs 1 > $blast_out 2>/dev/null";
    &process_cmd($cmd);
    
    if (-s $blast_out) {
        open (my $fh, $blast_out) or die "Error, cannot open file $blast_out";
        while (<$fh>) {
            chomp;
            my @x = split(/\t/);
            my $blast_line = join("^", @x);
            $blast_line =~ s/\s+//g;
            push (@blast_hits, $blast_line);
        }
    }
    
    $BLAST_CACHE{"$geneA--$geneB"} = [@blast_hits];

    return(@blast_hits);
}



####
sub process_cmd {
    my ($cmd) = @_;

    print STDERR "CMD: $cmd\n";
        
    my $ret = system($cmd);
    if ($ret) {

        die "Error, cmd $cmd died with ret $ret";
    }
    
    return;
}
    
        
####
sub merge_neighboring_nonref_splice {
    my ($fusions_aref, $ofh) = @_;

    my @ret_fusions;

    my %fusion_name_to_nonref_splice;

    foreach my $fusion (@$fusions_aref) {
        
        if ($fusion->{splice_type} eq "INCL_NON_REF_SPLICE") {
            my $fusion_name = $fusion->{fusion_name};
            push (@{$fusion_name_to_nonref_splice{$fusion_name}}, $fusion);
        }
        else {
            push (@ret_fusions, $fusion);
        }
    }

    foreach my $fusion_list_aref (values %fusion_name_to_nonref_splice) {
        
        my @nonref_fusions = @$fusion_list_aref;
        
        @nonref_fusions = reverse sort {$a->{score}<=>$b->{score}} @nonref_fusions;

        
        do {
        
            my $top_fusion = shift @nonref_fusions;
    
            my @remaining_fusions;
            foreach my $f (@nonref_fusions) {
                if (&fusions_within_range($top_fusion, $f, $AGGREGATE_NOVEL_JUNCTION_DIST)) {
                    print $ofh "#" . $f->{line} . "\tmerged into:\t" . $top_fusion->{line} . "\n"; # keep record of filtered and merged entries.
                    $top_fusion = &merge_fusions($top_fusion, $f);

                    
                }
                else {
                    push (@remaining_fusions, $f);
                }
            }

            @nonref_fusions = @remaining_fusions;
            
            push (@ret_fusions, $top_fusion);
            
        } while (@nonref_fusions);
        

    }

    return(@ret_fusions);
}


####
sub fusions_within_range {
    my ($fusionA, $fusionB, $max_dist) = @_;

    my @pts_A_left = split(/:/, $fusionA->{brkptA});
    my $coordA_left = $pts_A_left[-2];
    
    my @pts_A_right = split(/:/, $fusionA->{brkptB});
    my $coordA_right = $pts_A_right[-2];

    my @pts_B_left = split(/:/, $fusionB->{brkptA});
    my $coordB_left = $pts_B_left[-2];

    my @pts_B_right = split(/:/, $fusionB->{brkptB});
    my $coordB_right = $pts_B_right[-2];
    
    
    if ( abs($coordA_left - $coordB_left) <= $max_dist

         &&

         abs($coordA_right - $coordB_right) <= $max_dist ) {

        # within range
        return(1); # yes
    }

    else {

        return(0); # no
    }

}


####
sub merge_fusions {
    my ($fusion_keep, $fusion_subsume) = @_;

    my %junction_reads;
    foreach my $junction_read_list ($fusion_keep->{junction_reads}, $fusion_subsume->{junction_reads}) {

        my @juncs = split(/,/, $junction_read_list);
        foreach my $j (@juncs) {
            unless ($j eq ".") {
                $junction_reads{$j} = 1;
            }
        }
    }

    my %spanning_frags;
    foreach my $span_frag_list ($fusion_keep->{spanning_frags}, $fusion_subsume->{spanning_frags}) {

        my @spans = split(/,/, $span_frag_list);
        
        foreach my $span (@spans) {
            if ($span ne '.' && ! exists $junction_reads{$span}) {
                $spanning_frags{$span} = 1;
            }
        }
    }

    my @new_junc_read_list = keys %junction_reads;
    my @new_span_frag_list = keys %spanning_frags;

    my $new_count_junc_reads = scalar(@new_junc_read_list);
    my $new_count_span_frags = scalar(@new_span_frag_list);

    $fusion_keep->{J} = $new_count_junc_reads;
    $fusion_keep->{S} = $new_count_span_frags;

    $fusion_keep->{junction_reads} = join(",", @new_junc_read_list) || ".";
    $fusion_keep->{spanning_frags} = join(",", @new_span_frag_list) || ".";

    
    $fusion_keep->{score} = 4 * $new_count_junc_reads + $new_count_span_frags;
    

    return($fusion_keep);
}


####
sub remove_minor_nonref_isoforms {
    my ($fusions_aref, $ofh) = @_;
    
    my @fusions = reverse sort { $a->{J}<=>$b->{J} 
                                 ||
                                     $a->{S} <=> $b->{S} } @$fusions_aref;
    
    my %dominant_isoform_junc_support;
    my @ret_fusions;
    
    my %seen;
    
    foreach my $fusion (@fusions) {
        
        my $fusion_name = $fusion->{fusion_name};
        my $junction_support = $fusion->{J};
        my $span_support = $fusion->{S};

        my $splice_type = $fusion->{splice_type};


        if ($splice_type eq 'NO_JUNCTION_READS_IDENTIFIED') {
            if ($span_support < $MIN_SPAN_ONLY_SUPPORT) {
                print $ofh "#" . $fusion->{line} . "\tFILTERED DUE TO span-only support $span_support < $MIN_SPAN_ONLY_SUPPORT\n";
                next;
            }
        }
        
        if ($splice_type eq 'INCL_NON_REF_SPLICE' 
            && $junction_support < $MIN_NOVEL_JUNCTION_SUPPORT 
            && $span_support + $junction_support < $MIN_SPAN_ONLY_SUPPORT) {
            
            # skip it
            print $ofh "#" . $fusion->{line} . "\tFILTERED DUE TO junction support $junction_support < $MIN_NOVEL_JUNCTION_SUPPORT\n";
            next; 
            
        }
        
        if ($splice_type eq 'NO_JUNCTION_READS_IDENTIFIED') {
            if ($seen{$fusion_name}) {
                print $ofh "#" . $fusion->{line} . "\tFILTERED as redundant, already reported $fusion_name\n";
                next; 
            }
        }
        else {
            
            my $dominant_isoform_support = $dominant_isoform_junc_support{$fusion_name};
            if (defined $dominant_isoform_support) {
                
                my $pct_dom_iso_support = $junction_support / $dominant_isoform_support * 100;
                if ($pct_dom_iso_support < $MIN_ALT_PCT_JUNCTION) {
                    print $ofh "#" . $fusion->{line} . "\tFILTERED DUE TO ONLY $pct_dom_iso_support % of dominant isoform support ($dominant_isoform_support)\n";
                    next; 
                }
                
            }
        
            else {
                $dominant_isoform_junc_support{$fusion_name} = $junction_support;
            }
        }
        
        push (@ret_fusions, $fusion); # it's a keeper.

        $seen{$fusion_name} = 1;
        
    }
    
    return(@ret_fusions);
}
            
