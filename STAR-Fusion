#!/usr/bin/env perl

# contributed by Brian Haas, Broad Institute, 2015

use strict;
use warnings;
use Carp;
use Cwd;
use FindBin;
use lib ("$FindBin::Bin/lib");
use Pipeliner;
use Set::IntervalTree;
use File::Basename;

use Getopt::Long qw(:config posix_default no_ignore_case bundling pass_through);

my $UTILDIR = "$FindBin::Bin/util";


=recommended_STAR_settings

  # From Stransky et al. 2014   PMID: 25204415

   STAR --genomeDir Hg19.fa_star_index \
        --readFilesIn left.fq right.fq \
        --outSAMstrandField intronMotif \
        --outFilterIntronMotifs RemoveNoncanonicalUnannotated \
        --outReadsUnmapped None --chimSegmentMin 15 \
        --chimJunctionOverhangMin 15 \
        --alignMatesGapMax 200000 \
        --alignIntronMax 200000 \
        --runThreadN 4 \
        --outSAMtype BAM SortedByCoordinate 

=cut



## Options
my $out_prefix = "star-fusion";
my $chimeric_junction_file;
my $ref_GTF = "$FindBin::Bin/resources/gencode.v19.annotation.gtf.exons.protein_coding.gz";
my $ref_cdna = "$FindBin::Bin/resources/gencode.v19.annotation.gtf.exons.cdna.gz";
my $help_flag;
my $MIN_NOVEL_JUNCTION_SUPPORT = 3;
my $MIN_ALT_PCT_JUNCTION = 10.0;
my $AGGREGATE_NOVEL_JUNCTION_DIST = 5;
my $Evalue = 1e-3;
my $tmpdir = "/tmp";
my $verbose_level = 1;
my $MIN_JUNCTION_READS = 1;
my $MIN_SUM_FRAGS = 2;
my $MAX_PROMISCUITY = 3;  # perhaps a poor choice of words, but still a best fit IMHO.

my $usage = <<__EOUSAGE__;

###################################################################################
#
#  Required:
#
#    --chimeric_junction|J <string>     Chimeric.out.junction file
#
#  Optional:
#
#    --ref_GTF|G <string>                  reference annotation GTF file (ie. gencode.gtf)
#
#    --ref_cdna|C <string>                 reference cDNA sequences fasta file (generated specially based on gtf -see docs)
#
#    --min_junction_reads <int>            minimum number of junction-spanning reads required. Default: $MIN_JUNCTION_READS
#
#    --min_sum_frags <int>                 minimum fusion support = ( # junction_reads + # spanning_frags ) Default: $MIN_SUM_FRAGS
#
#    --max_promiscuity <int>               maximum number of partners allowed for a given fusion. Default: $MAX_PROMISCUITY
#
#
#    --min_novel_junction_support <int>    default: $MIN_NOVEL_JUNCTION_SUPPORT  (minimum of $MIN_NOVEL_JUNCTION_SUPPORT junction reads required if breakpoint
#                                                        lacks involvement of only reference junctions)
#
#    --min_alt_pct_junction <float>        default: $MIN_ALT_PCT_JUNCTION  ($MIN_ALT_PCT_JUNCTION % of the dominant isoform junction support)
#
#    --aggregate_novel_junction_dist <int>  default: $AGGREGATE_NOVEL_JUNCTION_DIST (non-ref junctions within $AGGREGATE_NOVEL_JUNCTION_DIST are merged into single calls)
#
#    --out_prefix|O <string>               output file prefix (default: $out_prefix)
#   
#    -E <float>                            E-value threshold for blast searches (default: 0.001)
#
#    --tmpdir <string>                     file for temporary files (default: /tmp)
#
#    --verbose_level <int>                 verbosity (default: $verbose_level, max=2)
#
#    --no_filter                           do not filter predictions.
#
###################################################################################


__EOUSAGE__

    ;


my $no_filter = 0;


&GetOptions ( 'help|h' => \$help_flag,
              
              'chimeric_junction|J=s' => \$chimeric_junction_file,
              'ref_GTF|G=s' => \$ref_GTF,
              'ref_cdna|C=s' => \$ref_cdna,
              
              'min_junction_reads=i' => \$MIN_JUNCTION_READS,
              'min_sum_frags=i' => \$MIN_SUM_FRAGS,
              'max_promiscuity=i' => \$MAX_PROMISCUITY,
              
              'min_novel_junction_support=i' => \$MIN_NOVEL_JUNCTION_SUPPORT,
              'min_alt_pct_junction=f' => \$MIN_ALT_PCT_JUNCTION,
              'aggregate_novel_junction_dist=i' => \$AGGREGATE_NOVEL_JUNCTION_DIST,
              'out_prefix|O=s' => \$out_prefix,

              'E=f' => \$Evalue,
              'tmpdir=s' => \$tmpdir,
              'verbose_level=i' => \$verbose_level,
    
              'no_filter' => \$no_filter,
    );


if ($help_flag) {
    die $usage;
}
unless ($chimeric_junction_file) {
    die $usage;
}
unless (-s $ref_GTF) {
    die "Error, cannot locate reference annotation file: $ref_GTF";
}
unless ( -s $ref_cdna || $no_filter ) {
    die "Error, cannot locate reference cdna file: $ref_cdna";
}


main: {

    my $out_prefix_basename = basename($out_prefix);
    my $out_prefix_dirname = dirname($out_prefix);
    
    my $intermediates_dir = "$out_prefix_dirname/$out_prefix_basename.interm_dir";
    unless (-d $intermediates_dir) {
        mkdir ($intermediates_dir) or die "Error, cannot mkdir $intermediates_dir";
    }
    
     
    my $pipeliner = new Pipeliner(-verbose => $verbose_level);
    
    ## predict fusions

    my $cmd = "$UTILDIR/STAR-Fusion.predict "
        . " -J  $chimeric_junction_file "
        . " -G $ref_GTF "
        . " -O $out_prefix ";
    
    $pipeliner->add_commands(new Command($cmd, "$intermediates_dir/$out_prefix_basename.STAR-Fusion.predict.ok"));

    my $predicted_fusions_file = "$out_prefix.fusion_candidates.preliminary";
    
    unless ($no_filter) {
           
        ## filter fusions
        
        $cmd = "$UTILDIR/STAR-Fusion.filter "
            . " --fusion_preds $predicted_fusions_file "
            . " --ref_cdna $ref_cdna "
            . " -E $Evalue "
            . " --tmpdir $tmpdir "
            . " --min_junction_reads $MIN_JUNCTION_READS "
            . " --min_sum_frags $MIN_SUM_FRAGS "
            . " --max_promiscuity $MAX_PROMISCUITY "
            . " --min_novel_junction_support $MIN_NOVEL_JUNCTION_SUPPORT "
            . " --min_alt_pct_junction $MIN_ALT_PCT_JUNCTION "
            . " --aggregate_novel_junction_dist $AGGREGATE_NOVEL_JUNCTION_DIST "
            . " --out_prefix $intermediates_dir/$out_prefix.fusion_candidates ";
        
        $pipeliner->add_commands(new Command($cmd, "$intermediates_dir/$out_prefix_basename.STAR-Fusion.filter.ok"));
        
        $pipeliner->add_commands(new Command("mv $intermediates_dir/$out_prefix_basename.fusion_candidates.final .", 
                                             "$intermediates_dir/$out_prefix_basename.mv_final.ok"));

        $pipeliner->add_commands(new Command("mv $intermediates_dir/$out_prefix_basename.fusion_candidates.final.abridged .", 
                                             "$intermediates_dir/$out_prefix_basename.mv_final_abridged.ok"));
        
    }
                                 
    $pipeliner->run();
    
    if ($no_filter) {
         
        print STDERR "\n\n *** Note: --no_filtering in effect, so outputs have not been filtered for likely false positives.\n";
        print STDERR "\n\tSee output: $out_prefix.fusion_candidates.preliminary\n\n";
    }
    else {
        
        print STDERR "\n\n\t* Process complete.  See output: $out_prefix.fusion_candidates.final (or .abridged version)\n\n\n";
    }
    
    exit(0);
    
}

####
sub process_cmd {
    my ($cmd) = @_;
    
    print STDERR "CMD: $cmd\n";
    
    my $ret = system($cmd);
    
    if ($ret) {
        die "Error, CMD: $cmd died with ret $ret";
    }

    return;
}


####
sub missing_required_program_installed {
    my (@required_progs) = @_;

    my $missing = 0;
    
    foreach my $prog (@required_progs) {

        my $path = `which $prog`;
        chomp $path;
        unless ($path && $path =~ /\w/) {
            $missing++;
            print STDERR "Error, cannot locate required program: $prog\n";
        }
        else {
            print STDERR "-found prog $prog at $path\n";
        }
    }
    
    return($missing);
}

